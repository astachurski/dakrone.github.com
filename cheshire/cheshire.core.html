<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>cheshire.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Cheshire 5.0.1-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="cheshire.core.html"><span>cheshire.core</span></a></li><li><a href="cheshire.custom.html"><span>cheshire.custom</span></a></li><li><a href="cheshire.factory.html"><span>cheshire.factory</span></a></li><li><a href="cheshire.generate.html"><span>cheshire.generate</span></a></li><li><a href="cheshire.parse.html"><span>cheshire.parse</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="cheshire.core.html#var-eof"><span>eof</span></a></li><li><a href="cheshire.core.html#var-generate-smile"><span>generate-smile</span></a></li><li><a href="cheshire.core.html#var-generate-stream"><span>generate-stream</span></a></li><li><a href="cheshire.core.html#var-generate-string"><span>generate-string</span></a></li><li><a href="cheshire.core.html#var-parse-smile"><span>parse-smile</span></a></li><li><a href="cheshire.core.html#var-parse-stream"><span>parse-stream</span></a></li><li><a href="cheshire.core.html#var-parse-string"><span>parse-string</span></a></li><li><a href="cheshire.core.html#var-parsed-seq"><span>parsed-seq</span></a></li><li><a href="cheshire.core.html#var-parsed-smile-seq"><span>parsed-smile-seq</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>cheshire.core documentation</h2><pre class="doc">Main encoding and decoding namespace.
</pre><div class="public" id="var-eof"><h3>eof</h3><div class="usage"></div><pre class="doc">Object used to determine end of lazy parsing attempt.
</pre></div><div class="public" id="var-generate-smile"><h3>generate-smile</h3><div class="usage"><code>(generate-smile obj)</code><code>(generate-smile obj opt-map)</code></div><pre class="doc">Returns a SMILE-encoded byte-array for the given Clojure object.
Takes an optional date format string that Date objects will be encoded with.

The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'</pre></div><div class="public" id="var-generate-stream"><h3>generate-stream</h3><div class="usage"><code>(generate-stream obj writer)</code><code>(generate-stream obj writer opt-map)</code></div><pre class="doc">Returns a BufferedWriter for the given Clojure object with the.
JSON-encoded data written to the writer. Takes an optional date
format string that Date objects will be encoded with.

The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'</pre></div><div class="public" id="var-generate-string"><h3>generate-string</h3><div class="usage"><code>(generate-string obj)</code><code>(generate-string obj opt-map)</code></div><pre class="doc">Returns a JSON-encoding String for the given Clojure object. Takes an
optional date format string that Date objects will be encoded with.

The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'</pre></div><div class="public" id="var-parse-smile"><h3>parse-smile</h3><div class="usage"><code>(parse-smile bytes &amp; [key-fn array-coerce-fn])</code></div><pre class="doc">Returns the Clojure object corresponding to the given SMILE-encoded bytes.
An optional key-fn argument can be either true (to coerce keys to keywords),
false to leave them as strings, or a function to provide custom coercion.

The array-coerce-fn is an optional function taking the name of an array field,
and returning the collection to be used for array values.</pre></div><div class="public" id="var-parse-stream"><h3>parse-stream</h3><div class="usage"><code>(parse-stream rdr &amp; [key-fn array-coerce-fn])</code></div><pre class="doc">Returns the Clojure object corresponding to the given reader, reader must
implement BufferedReader. An optional key-fn argument can be either true (to
coerce keys to keywords),false to leave them as strings, or a function to
provide custom coercion.

The array-coerce-fn is an optional function taking the name of an array field,
and returning the collection to be used for array values.
If laziness is needed, see parsed-seq.</pre></div><div class="public" id="var-parse-string"><h3>parse-string</h3><div class="usage"><code>(parse-string string &amp; [key-fn array-coerce-fn])</code></div><pre class="doc">Returns the Clojure object corresponding to the given JSON-encoded string.
An optional key-fn argument can be either true (to coerce keys to keywords),
false to leave them as strings, or a function to provide custom coercion.

The array-coerce-fn is an optional function taking the name of an array field,
and returning the collection to be used for array values.</pre></div><div class="public" id="var-parsed-seq"><h3>parsed-seq</h3><div class="usage"><code>(parsed-seq reader &amp; [key-fn array-coerce-fn])</code></div><pre class="doc">Returns a lazy seq of Clojure objects corresponding to the JSON read from
the given reader. The seq continues until the end of the reader is reached.

The array-coerce-fn is an optional function taking the name of an array field,
and returning the collection to be used for array values.
If non-laziness is needed, see parse-stream.</pre></div><div class="public" id="var-parsed-smile-seq"><h3>parsed-smile-seq</h3><div class="usage"><code>(parsed-smile-seq reader &amp; [key-fn array-coerce-fn])</code></div><pre class="doc">Returns a lazy seq of Clojure objects corresponding to the SMILE read from
the given reader. The seq continues until the end of the reader is reached.

The array-coerce-fn is an optional function taking the name of an array field,
and returning the collection to be used for array values.</pre></div></div></body></html>